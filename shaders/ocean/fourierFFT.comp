
#version 460

#define PI 3.1415926535897932f
#define TWO_PI 6.2831853071795864f

layout (rg32f, binding = 0) uniform readonly image2D readBuff;
layout (rg32f, binding = 1) uniform writeonly image2D writeBuff;

vec2 ComplexMul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.y * w.x + z.x * w.y);
}

shared vec2 values[2][DISP_MAP_SIZE];

layout (local_size_x = DISP_MAP_SIZE) in;

void main() {
    const float N = float(DISP_MAP_SIZE);

    int z = int(gl_WorkGroupID.x);
    int x = int(gl_LocalInvocationID.x);

    int nj = (bitfieldReverse(x) >> (32 - LOG2_DISP_MAP_SIZE)) & (DISP_MAP_SIZE - 1);
    values[0][nj] = imageLoad(readBuff, ivec2(z, x)).rg;
    barrier();

    int src = 0;

    for (int s = 1; s <= LOG2_DISP_MAP_SIZE; ++s) {
        int m = 1 << s;
        int mh = m >> 1;

        int k = (x * (DISP_MAP_SIZE / m)) & (DISP_MAP_SIZE - 1);
        int i = (x & ~(m - 1));
        int j = (x & (mh - 1));

        float theta = (TWO_PI * float(k)) / N;
        vec2 WNk = vec2(cos(theta), sin(theta));

        vec2 input1 = values[src][i + j + mh];
        vec2 input2 = values[src][i + j];

        src = 1 - src;
        values[src][x] = input2 + ComplexMul(WNk, input1);
        barrier();
    }

    vec2 result = values[src][x];
    imageStore(writeBuff, ivec2(x, z), vec4(result, 0.0f, 1.0f));
}